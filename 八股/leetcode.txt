贪心：
https://leetcode.cn/problems/binary-tree-cameras/
动规：
打家劫舍3：https://leetcode.cn/problems/house-robber-iii/

https://cjcx.neea.edu.cn/html1/folder/21045/4883-1.htm

分布式锁，setnx（set if not exist）设置分布式锁时间，但是难以控制时间的长短，
短了，加锁后业务没执行完就释放锁
redisson加锁后开启看门狗线程监听业务的进行，默认每10秒一次续时间，
锁最后手动释放，看门狗不再监听，其他线程加锁时，如果有锁就自旋锁，
循环到一定次数后会失败（重试机制）。优点高并发时可以增强分布式锁的使用性能。
lock.trylock方法，如果设置了锁失效时间，看门狗则不再监听，也就不再续期。
加锁、设置过期时间和锁续期使用了lua脚本，调用多条redis命令来保证命令执行的原子性。
可重入机制，可以避免死锁情况，通过hash结构记录线程id和重入次数，加锁+1，解锁至0则释放。

哨兵模式：保证主从复制的数据一致性，主节点挂了，从节点出一个来作为主节点。
但会出现锁丧失互斥性问题。红锁来保证锁的互斥性（很少使用，性能差，复杂繁琐）
redis AP思想来保证最终一致，不行的话使用zookeeper来保证数据的强一致性。

redis集群方案：
主从复制：单节点Redis的并发能力是有上限的，要进一步提
高Redis的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多
从，主节点负责写数据，从节点负责读数据，主节点写入数据之后，需要把
数据同步到从节点中
流程：主从同步分为了两个阶段，一个是全量同步，一个是
增量同步
全量同步是指从节点第一次与主节点建立连接的时候使用全量同步，流程是
这样的：
第一：从节点请求主节点同步数据，其中从节点会携带自己的replication id
和offset偏移量。
第二：主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节
点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点
就会把自己的replication id和offset发送给从节点，让从节点与主节点的信息
保持一致。
第三：在同时主节点会执行bgsave，生成rdb文件后，发送给从节点去执
行，从节点先把自己的数据清空，然后执行主节点发送过来的rdb文件，这
样就保持了一致
当然，如果在rdb生成执行期间，依然有请求到了主节点，
而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件repl_baklog，
最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，
后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步
增量同步指的是，当从节点服务重启之后，数据就不一致了，所以这个时
候，从节点会请求主节点同步数据，主节点还是判断不是第一次请求，不是
第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后
的数据，发送给从节点进行数据同步

怎么保证Redis的高并发高可用
首先可以搭建主从集群，再加上使用redis中的哨兵模式，
哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动
故障恢复、通知；如果master故障，Sentinel会将一个slave提升为master。
当故障实例恢复后也以新的master为主；同时Sentinel也充当Redis客户端的
服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户
端，所以一般项目都会采用哨兵的模式来保证redis的高并发高可用

主从(1主1从)+哨兵就可以了。单节点不超过10G内存，
如果Redis内存不足则可以给不同服务分配独立的Redis主从节点

哨兵模式：
哨兵选主规则
首先判断主与从节点断开时间长短，如超过指定值就排该从节点
然后判断从节点的slave-priority值，越小优先级越高
如果slave-prority一样，则判断slave节点的offset值，越大优先级越高
最后是判断slave节点的运行id大小，越小优先级越高

分片集群读取数据：Redis 集群引入了哈希槽的概念，有 16384 个哈希槽，集群中每个主节点绑
定了一定范围的哈希槽范围， key通过 CRC16 校验后对 16384 取模来决定放
置哪个槽，通过槽找到对应的节点进行存储。
取值的逻辑是一样的

脑裂问题：
redis中有两个配置参数
min-replicas-to-write 1 表示最少的salve节点为1个
min-replicas-max-lag 5表示数据复制和同步的延迟不能超过5秒
一个是拒绝没有slave的master写入数据，一个是缩小丢失数据的时间
分片集群：



为什么redis单线程还快，瓶颈是网络延迟而不是执行速度
1、完全基于内存的，C语言编写
2、采用单线程，避免不必要的上下文切换可竞争条件
3、使用多路I/O复用模型，非阻塞IO
例如：bgsave 和 bgrewriteaof 都是在后台执行操作，不影响主线程的正常
使用，不会产生阻塞

****************************
8.5
****************************
单列集合：
Collection（list，set）：
public boolean add(E e)把给定的对象添加到当前集合中
public void clear()清空集合中所有的元素
public boolean remove(E e)把给定的对象在当前集合中删除
public boolean contains(object obj)判断当前集合中是香包含给定的对象
public boolean isEmpty()判断当前集合是否为空
public int size()返回集合中元素的个数/集合的长度

遍历方式：迭代器，增强for，foreach（lambda表达式，consumer），list可以索引遍历

Treeset(比较器):
①comparable：在需要排序的对象内实现此接口，补泛型为此类对象
然后重写此方法compareTo()
②comparetor（优先级大于①）：函数式接口，new TreeSet<>(comparetor{});
可以转换为lambda表达式

1．如果想要集合中的元素可重复，用ArrayList集合，基于数组的。（用的最多)
2．如果想要集合中的元素可重复，而且当前的增删操作明显多于查询，用LinkedList集合，基于链表的。
3．如果想对集合中的元素去重，用HashSet集合，基于哈希表的。(用的最多)
4．如果想对集合中的元素去重，而且保证存取顺序，用LinkedHashet集合，基于哈希表和双链表，效率低于Hashset。
5．如果想对集合中的元素进行排序上，用Treeset集合，基于红黑树。后续也可以用List集合实现排序。

双列集合：
v put(K key,v value)添加元素
v remove(object key)根据键删除键值对元素
void clear()移除所有的键值对元素
boolean containsKey(object key)判断集合是否包含指定的键
boolean containsValue(0bject value)判断集合是否包含指定的值
boolean isEmpty()判断集合是否为空
int size()集合的长度，也就是集合中键值对的个数

遍历方式：
①键找值，拿到键的set：Set<>keys=map.keySet();
增强for (string key : keys) 
②键值对，拿到键值对set：Set<Map.Entry<o,o>> entries = map.entrySet();
增强for(Map.Entry<o,o>:entries)
③Lambda方法：foreach（(key,value)->{}）;

总结：
hash的都需要依赖hashCode方法和equals方法保证唯一性
Tree底层红黑树


可变参数写最后且只能有一个可变参数如：f(String s, int...a)

集合类的工具类Collections
public static <T> boolean addAll(collection<T>c, T... elements)批量添加元素
public static void shuffle(List<?> list)打乱List集合元素的顺序
public static <T> void sort(List<T> list)排序
public static <T> void sort(List<T> list，comparator<T> c)根据指定的规则进行排序
public static <T> int binarySearch (List<T> list，T key)以二分查找法查找元素
public static <T> void copy(List<T> dest， list<T> src)拷贝集合中的元素
public static <T> int fill (List<T> list, T obj)使用指定的元素填充集合
public static <T> void max/min(collection<T> col1)根据默认的自然排序获取最大/小值
public static <T> void swap(List<?> list, int i, int j)交换集合中指定位置的元素

JVM优点：①一次编写，到处运行②自动内存管理，垃圾回收机制
程序计数器特点：线程私有的，每个线程一份，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。
作用：
①指令定位：程序计数器指示了当前正在执行的指令的地址或索引。在执行Java字节码时，JVM会根据程序计数器的值来获取下一条要执行的指令。
②线程独立：每个线程都有自己独立的程序计数器，用于跟踪各个线程的执行状态。这样可以保证每个线程都能独立执行，并且能正确地恢复到之前执行的位置。
③分支和循环控制：程序计数器在分支语句（例如if-else）和循环语句（例如for、while）中起着重要作用。通过程序计数器的值，JVM可以正确地控制程序的流程，使得程序能够按照预期执行。
④方法调用和返回：在Java程序中，方法调用和返回是常见的操作。程序计数器在方法调用时记录当前执行的位置，当方法返回时，可以根据程序计数器的值恢复到方法调用的位置，继续执行后续指令。
⑤异常处理：程序计数器也在异常处理中发挥着作用。当发生异常时，JVM会使用程序计数器来确定异常处理代码的入口，以便正确地处理异常。


堆，线程共享的区域:主要用来保存对象实例，数组等，内存不够则抛出OutOfMemoryError异常。
本地内存包括直接内存和元空间，永久代移出堆，来实现对堆内存的优化，防止堆内存溢出
（即本地方法区:保存的类信息、静态变量、常量、编译后的代码）
堆：年轻代（eden，s0，s1）-> 老年代


虚拟机栈：每个线程运行时所需要的内存，称为虚拟机栈，
先进后出每个栈由多个栈帧(frame)组成，对应着每次方法调用时所占用的内存
每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

栈内存分配越大越好吗?
未必，默认的栈内存通常为1024k，栈过大会导致线程数变少

方法内的局部变量是否线程安全?
如果方法内局部变量没有逃离方法的作用范围，它是线程安全的
如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

栈内存溢出情况：
栈帧过多导致栈内存溢出，典型问题:递归调用
栈帧过大导致栈内存溢出



方法区(Method Area)是各个线程共享的内存区域主要存储类的信息、运行时常量池虚拟机启动的时候创建，
关闭虚拟机时释放。如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace

常量池:可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名方法名、参数类型、字面量等信息
当类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址

直接内存:并不属于JVM中的内存结构，不由JVM进行管理，是虚拟机的系统内存。
常见于 NIO 操作时，用于数据缓冲区，它分配回收成本较高，但读写性能高


类加载器：JVM只会运行二进制文件，类加载器的作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。
启动类加载器，由C++编写实现，jre/lib
扩展类加载器，jre/lib/ext
应用类加载器，加载开发者自己编写的Java类，用于加载classPath下的类
自定义类加载器，继承classLoader，实现自定义类加载规则

双亲委派机制：加载某一个类，先委托上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类
目的：通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性为了安全，保证类库API不会被修改
BootstrapClassLoader->ExtensionClassLoader->AppClassLoader->CustomClassLoader

加载:查找和导入class文件
验证:保证加载类的准确性
准备:为类变量分配内存并设置类变量初始值
解析:把类中的符号引用转换为直接引用
初始化:对类的静态变量，静态代码块执行初始化操作
使用:JVM 开始从入口方法开始执行用户的程序代码
卸载:当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象。



******************
8.6
******************
JVM有两种线程，一种叫叫守护线程，一种叫非守护线程，main函数就是个非守护线程，
虚拟机的gc就是一个守护线程。java的虚拟机中，只要有任何非守护线程还没有结束，
java虚拟机的实例都不会退出，所以即使main函数这个非守护线程退出，
但是由于在main函数中启动的匿名线程也是非守护线程，它还没有结束，所以jvm没办法退出
java虚拟机的生命周期，当一个java应用main函数启动时虚拟机也同时被启动，
而只有当在虚拟机实例中的所有非守护进程都结束时，java虚拟机实例才结束生命。

java常量池不在堆中也不在栈中，是独立的内存空间管理。
1. 栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。）
2. 堆：存放所有new出来的对象。
3. 常量池：存放字符串常量和基本类型常量（public static final）。
对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，
如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。

方法区包含：类信息、常量、静态变量、运行时常量池，线程共享，不在JVM内存，属于本地内存。
堆包含：字符串常量池，数组和new对象，线程共享，受GC管理
栈包含：方法调用和局部变量的运行时数据区域，每个线程有自己的栈空间，不受GC管理。

JVM给对象分配内存的策略
1. 指针碰撞： 这种方式在内存中放一个指针作为分界指示器将使用过的内存放在一边，空闲的放在另一边，通过指针挪动完成分配。
2. 空闲列表： 对于 Java 堆内存不规整的情况，虚拟机必须维护一个列表记录哪些内存可用，在分配时从列表中找到一块足够大的空间划分给对象并更新列表记录。

java对象内存分配是如何保证线程安全的
1. 对分配内存空间采用CAS机制，配合失败重试的方式保证更新操作的原子性。该方式效率低。
2. 每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块"私有"内存中分配。一般采用这种策略。

对象的内存布局
对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。
对象头主要包含两部分数据： MarkWord、类型指针。MarkWord 用于存储哈希码（HashCode）、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程ID等信息。类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数据，实例数据存储代码中所定义的各种类型的字段信息。
对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。

**********************
8.7
**********************

标记方法
①引用计数法，引用数被引用+1，置空-1，缺点：循环引用无法清除。基本不用。
②可达性分析法，GCroot（虚拟机栈引用的对象，方法区静态引用的对象，方法区常量引用的对象）

清除方法
①标记清除，直接清，缺点：内存碎片。基本不用
②标记整理，优点，内存连续，缺点把所有存活对象都标记完毕，再进行整理
③标记复制，优点：在垃圾对象多的情况下，效率较高；清理后，内存无碎片
缺点：分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低

MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW）
Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有
FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长（STW），应尽力避免

垃圾回收器
①串行垃圾收集器
Serial和Serial Old串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较
小，适合个人电脑
Serial 作用于新生代，采用复制算法
Serial Old 作用于老年代，采用标记-整理算法
垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停
（STW），等待垃圾回收的完成。
②并行垃圾收集器
Parallel New和Parallel Old是一个并行垃圾回收器，JDK8默认使用此垃圾回收器
Parallel New作用于新生代，采用复制算法
Parallel Old作用于老年代，采用标记-整理算法
垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停（STW），
等待垃圾回收的完成。
③CMS（并发）垃圾收集器
CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回
收器，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目
标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应
用仍然能正常运行。
④G1（JDK9之后默认使用G1）：应用于新生代和老年代
划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous（专为大对象准备）
采用复制算法，优点：响应时间与吞吐量兼顾
分成三个阶段：
a.新生代回收：参与复制的有 eden
b.老年代超过45%（默认阈值）会触发并发标记：参与复制的有 eden，survivor
c.混合收集：参与复制的有 eden、survivor、old
如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC

java的引用类型
强引用（采用 new 方法）： 被强引用关联的对象不会被回收。
软引用（采用 SoftReference 类来创建）：被软引用关联的对象只有在内存不够的情况下才会被回收。
弱引用（采用WeakReference 类来创建）：垃圾收集器碰到即回收，也就是说它只能存活到下一次垃圾回收发生之前。
虚引用（无法通过该引用获取对象）：唯一目的就是为了能在对象被回收时收到一个系统通知。
虚引用必须与引用队列联合使用。由Reference Handler 线程调用虚引用相关方法释放直接内存

JVM调优：
①tomcat的设置vm参数
②springboot项目jar文件启动

1）设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。
-Xms：设置堆的初始化大小
-Xmx：设置堆的最大大小
2） 设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。Java官方通过增大Eden区的大小，
来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满的时候，由于占用的空间较大，导致释放缓慢，
此时STW的时间较长，因此需要按照程序情况去调优。
-XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3
3）年轻代和老年代默认比例为1：2。可以通过调整二者空间大小比率来设置两者的大小。
-XX:newSize 设置年轻代的初始大小
-XX:MaxNewSize 设置年轻代的最大大小， 初始大小和最大大小两个值通常相同
4）线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参
数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更
多的线程，但这实际上还受限于操作系统。
-Xss 对每个线程stack大小的调整,-Xss128k
5）一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老
年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年
轻代，从而避免full GC，使用-Xmn设置年轻代的大小
6）系统CPU持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运
维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决。
7）对于占用内存比较多的大对象，一般会选择在老年代分配内存。如果在年轻
代给大对象分配内存，年轻代内存不够了，就要在eden区移动大量对象到老年
代，然后这些移动的对象可能很快消亡，因此导致full GC。通过设置参数：-
XX:PetenureSizeThreshold=1000000，单位为B，标明对象大小超过1M时，在老
年代(tenured)分配内存空间。
8）一般情况下，年轻对象放在eden区，当第一次GC后，如果对象还存活，放到survivor区，此后，每GC一次，年龄增加1，当对象的年龄达到阈值，
就被放到tenured老年区。这个阈值可以同构-XX:MaxTenuringThreshold设置。如果想让对象留在年轻代，可以设置比较大的阈值。
-XX:+UseParallelGC:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。
-XX:+UseParallelOldGC:设置老年代使用并行垃圾回收收集器。
9）尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而系统的性能。
-XX:+LargePageSizeInBytes 设置内存页的大小
10）使用非占用的垃圾收集器。
-XX:+UseConcMarkSweepGC老年代使用CMS收集器降低停顿。

参数汇总：
-Xms 初始堆大小
-Xmx 最大堆大小
-XX:NewSize 年轻代大小
-XX:MaxNewSize 年轻代最大值
-XX:PermSize 永生代初始值
-XX:MaxPermSize 永生代最大值
-XX:NewRatio 新生代与老年代的比例

调优工具：
jps（Java Process Status）：输出JVM中运行的进程状态信息(现在一般使用jconsole)
jstack：查看java进程内线程的堆栈信息。
jmap：用于生成堆转存快照
jhat：用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）
jstat：JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。

内存泄露的排查思路
原因：
①如果线程请求分配的栈容量超过java虚拟机栈允许的最大容量的时候，java虚拟机将抛出一个StackOverFlowError异常
②如果java虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成拓展，
或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个OutOfMemoryError异常
③如果一次加载的类太多，元空间内存不足，则会报OutOfMemoryError:Metaspace

*****************************
8.8设计模式
*****************************
创建型模式（Creational Patterns）：这些模式关注如何创建对象，以便在系统中实例化对象的过程更加灵活、可扩展和独立。
单例模式（Singleton）
工厂模式（Factory）
抽象工厂模式（Abstract Factory）
建造者模式（Builder）
原型模式（Prototype）

结构型模式（Structural Patterns）：这些模式关注如何在类和对象之间形成更大的结构，以便更好地实现对象间的关联和组合。
适配器模式（Adapter）
桥接模式（Bridge）
组合模式（Composite）
装饰器模式（Decorator）
外观模式（Facade）
享元模式（Flyweight）
代理模式（Proxy）

行为型模式（Behavioral Patterns）：这些模式关注对象之间的通信和协作，以便更好地定义对象的责任和交互方式。
责任链模式（Chain of Responsibility）
命令模式（Command）
解释器模式（Interpreter）
迭代器模式（Iterator）
中介者模式（Mediator）
备忘录模式（Memento）
观察者模式（Observer）
状态模式（State）
策略模式（Strategy）
模板方法模式（Template Method）
访问者模式（Visitor）



工厂模式最大的优点：解耦。
开闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，
实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。
①简单工厂模式：不是一种设计模式，反而比较像是一种编程习惯。
简单工厂包含如下角色：
抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。
具体产品 ：实现或者继承抽象产品的子类
具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。
优点：
封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，
如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。
缺点：增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。
②静态工厂模式：在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。
※③工厂方法模式：针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。
工厂方法模式的主要角色：
抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。
具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。
优点:用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。
在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则:
缺点:每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度
④抽象工厂模式（工厂的工厂）：用的较少
优点:当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象
缺点:当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改



策略模式
该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户
它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理

策略模式的主要角色如下
抽象策略(Strategy)类:这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口.
具体策略(Concrete Strategy)类: 实现了抽象策略定义的接口，提供具体的算法实现或行为。
环境 (Context)类:持有一个策略类的引用，最终给客户端调用。
优点:
策略类之间可以自由切换
易于扩展
避免使用多重条件选择语句 (if else)，充分体现面向对象设计思想
缺点:
客户端必须知道所有的策略类，并自行决定使用哪一个策略类
策略模式将造成产生很多策略类

责任链模式（：责任链模式是一种行为型设计模式，它通过将多个处理对象连接成一条链，每个对象都可以选择处理请求或将请求传递给下一个处理对象。
这种模式将请求的发送者和接收者解耦，允许多个对象都有机会处理请求。
结构：责任链模式由一系列处理对象组成，每个对象都包含一个对下一个处理对象的引用，形成一个链。
客户端将请求发送给第一个处理对象，然后沿着链条传递，直到有一个对象处理请求或链条结束。
使用场景：当有多个对象可以处理请求，而且不确定哪个对象会处理请求时，可以使用责任链模式。适用于日志记录、权限校验、请求过滤等场景。
优点：降低了请求发送者和接收者之间的耦合度，增强了系统的灵活性和可扩展性。允许动态地添加、修改或重新排序处理对象。
缺点：可能会导致请求的传递时间较长，需要注意设计链条的合理性和性能。
示例场景：
假设有一个处理订单的系统，订单需要经过多个处理步骤，如验证、优惠券应用、库存检查等。
不同的处理步骤可能由不同的处理对象负责。这时可以使用责任链模式，将每个处理步骤封装成一个处理对象，形成一个处理链条，
每个处理对象都可以决定是否处理请求或将请求传递给下一个对象。



单例模式（Singleton）：
描述：确保一个类只有一个实例，并提供一个全局访问点。
使用场景：需要确保只有一个实例的情况，如数据库连接池、线程池、日志记录器等。
优点：节省资源，避免重复创建实例，方便控制全局资源。
缺点：可能引入全局状态，不适合多线程环境下没有合适同步措施。

工厂模式（Factory）：
描述：定义一个创建对象的接口，由子类决定实例化哪个类。
使用场景：需要创建多种相关对象的情况，希望避免直接实例化对象。
优点：封装了对象创建过程，易于扩展，遵循开闭原则。
缺点：增加了类的个数，可能会导致继承层次较深。

观察者模式（Observer）：
描述：定义对象间的一对多依赖关系，当一个对象状态发生改变时，其所有依赖者都会收到通知。
使用场景：需要实现对象间的动态通知和更新，如事件处理、GUI组件等。
优点：松耦合，观察者和被观察者可以独立变化，增强了可复用性和可维护性。
缺点：可能引起循环依赖问题，需要注意实现细节。

策略模式（Strategy）：
描述：定义一系列算法，将每个算法封装成一个独立的类，使它们可以互相替换。
使用场景：需要在运行时选择不同的算法或行为的情况，如排序、支付方式等。
优点：简化算法的扩展和切换，提高代码可读性和可维护性。
缺点：可能增加类的数量，需要额外的类来实现每个策略。

适配器模式（Adapter）：
描述：将一个类的接口转换成客户端所期望的另一个接口，解决接口不兼容问题。
使用场景：需要使用现有接口，但接口与需求不匹配时，或需要在不修改源代码的情况下适应新接口。
优点：解耦了目标和适配者，提高了复用性，灵活性更好。
缺点：增加了适配器层，可能引入一些性能开销。

装饰器模式（Decorator）：
描述：装饰器模式允许在不修改现有对象结构的情况下，动态地添加功能。通过将功能分散到不同的装饰器中，实现灵活的功能组合。
使用场景：需要对现有对象的功能进行扩展，但又不希望修改现有代码。常用于添加日志记录、权限校验等。
优点：遵循开闭原则，不需要修改现有代码，灵活性高，可动态组合功能。
缺点：可能引入过多的装饰器类，增加复杂度。

代理模式（Proxy）：
描述：代理模式用于控制对其他对象的访问，提供一个代理对象来控制对真实对象的访问。常见的代理包括远程代理、虚拟代理等。
使用场景：需要对对象访问进行控制或者增加附加功能，如延迟加载、权限控制等。
优点：实现了对真实对象的隔离，提供了更灵活的控制和扩展点。
缺点：增加了代理对象，可能引入一些性能开销。

模板方法模式（Template Method）：
描述：模板方法模式定义了一个算法的框架，将其中的某些步骤延迟到子类实现。允许子类重定义算法的某些部分，但保持算法的结构不变。
使用场景：需要定义一个算法的骨架，但其中的某些步骤可以由子类自行实现。
优点：遵循开闭原则，提供了算法骨架的复用性，允许子类自定义部分实现。
缺点：可能引入复杂的类继承关系。

状态模式（State）：
描述：状态模式允许对象在内部状态改变时改变其行为，使对象看起来似乎修改了其类。
使用场景：当对象的行为随内部状态改变而变化时，可以使用状态模式来封装状态相关的行为。
优点：将状态与行为解耦，遵循开闭原则，易于增加新的状态。
缺点：可能引入较多的状态类，增加复杂性。

命令模式（Command）：
描述：命令模式将请求封装成对象，以便将请求的调用者和实际执行者解耦。通过创建命令对象，可以实现命令的撤销和重做等功能。
使用场景：需要将请求封装成对象，或者需要实现命令的撤销和重做功能。
优点：解耦命令的请求者和执行者，灵活性高，支持撤销和重做。
缺点：可能会引入大量的命令类。
************************************************
8.9多线程补充
************************************************
重量级锁：底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。
轻量级锁：线程加锁的时间是错开的(也就是没有竞争)，可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性
偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令

你谈谈JMM (Java内存模型
JMM(Java Memory Model)Java内存模型，定义了共享内存中多线程程序读写操作的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性
JMM把内存分为两块，一块是私有线程的工作区域(工作内存)，一块是所有线程的共享区域(主内存)
线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存

CAS的全称是: Compare And Swap(比较再交换);它体现的一种乐观锁的思想在无锁状态下保证线程操作数据的原子性。
CAS使用到的地方很多:AQS框架、AtomicXXX类
在操作共享变量的时候使用的自旋锁，效率上更高一些
CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现
缺点：自旋时CPU 带来高消耗，不能保证代码块原子性

乐观锁和悲观锁的区别
CAS是基于乐观锁的思想:最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。
synchronized是基于悲观锁的思想: 最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。

volatile作用：保证线程间的可见性（屏蔽修饰的变量的及时编译器JIT）；禁止进行指令重排序
volatile使用技巧：写变量让volatile修饰的变量的在代码最后位置；读变量让volatile修饰的变量的在代码最开始位置

AQS：是多线程中的队列同步器。是一种锁机制，它是做为一个基础框架使用的像ReentrantLock、Semaphore都是基于AQS实现的
AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程
在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0(无锁状态)，如果队列中的有一个线程修改成功了state为1，则当前线程就相等于获取了资源
在对state修改的时候使用的cas操作，保证多个线程修改的情况下原子性

ReentrantLock翻译过来是可重入锁，相对于synchronized它具备以下特点
1.可中断lock.lockInterruptibly()
2.可以设置超时时间
3.可以设置公平锁
4.支持多个条件变量
5.与synchronized一样，都支持重入

ReentrantLock的实现原理
1.ReentrantLock表示支持重新进入的锁，调用lock 方法获取了锁之后，再次调用lock，是不会再阻塞
2.ReentrantLock主要利用CAS+AQS队列来实现
3.支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可以传参设置为公平锁

synchronized和Lock有什么区别 ?
语法层面
synchronized 是关键字，源码在jvm 中，用c++ 语言实现
Lock 是接口，源码由idk 提供，用java 语言实现
使用 synchronized 时，退出同步代码块锁会自动释放，而使用Lock 时，需要手动调用unlock 方法释放锁
功能层面
二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能
Lock 提供了许多 synchronized 不具备的功能，例如公平锁、可打断、可超时、多条件变量
Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock(读写锁)
性能层面
在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖
在竞争激烈时，Lock 的实现通常会提供更好的性能

1.死锁产生的条件是什么?
一个线程需要同时获取多把锁，这时就容易发生死锁
必要条件：
互斥条件：每个资源都被分配给了一个进程或者资源是可用的
保持和等待条件：已经获取资源的进程被认为能够获取新的资源
不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放
循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。
2.如何进行死锁诊断?
当程序出现了死锁现象，我们可以使用idk自带的工具: jps和jstack
jps:输出VM中运行的进程状态信息
jstack:查看ava进程内线程的堆栈信息，查看日志，检查是否有死锁如果有死锁现象，需要查看具体代码分析后，可修复
可视化工具jconsole、VisualVM也可以检查死锁问题

ConcurrentHashMap
1底层数据结构:
JDK1.7底层采用分段的数组+链表实现
JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树
2.加锁的方式
JDK1.7采用Segment分段锁，底层使用的是ReentrantLock
JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑二叉树的首点，相对Segment分段锁粒度更细，性能更好

*****************************************
8.10消息中间件
*****************************************


Spring事务传播级别有以下几种：
REQUIRED（默认）：如果当前存在事务，则加入当前事务，如果当前没有事务，则新建一个事务。这是最常用的传播级别。
SUPPORTS：如果当前存在事务，则加入当前事务，如果当前没有事务，则以非事务的方式执行。
MANDATORY：如果当前存在事务，则加入当前事务，如果当前没有事务，则抛出异常。
REQUIRES_NEW：无论当前是否存在事务，都会新建一个事务，如果当前存在事务，则将其挂起。
NOT_SUPPORTED：以非事务的方式执行，如果当前存在事务，则将其挂起。
NEVER：以非事务的方式执行，如果当前存在事务，则抛出异常。
NESTED：如果当前存在事务，则在嵌套事务内执行。嵌套事务是独立于外部事务的子事务，它可以回滚而不影响外部事务。

面向对象设计原则：
①单一职责原则（Single Responsibility Principle，SRP）：
每个类或模块应该只负责一个单一的功能或职责。这意味着一个类应该只有一个引起它变化的原因。分离不同职责有助于减少代码的复杂性，使单元测试更容易，并且在修改一个职责时不会影响其他职责。
②开闭原则（Open/Closed Principle，OCP）：
软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。这意味着可以通过扩展现有的代码来增加新的功能，而不需要修改现有的代码。这有助于减少代码的风险，使系统更容易维护和扩展。
③里氏替换原则（Liskov Substitution Principle，LSP）：
子类应该能够替换其父类，而不会影响程序的正确性。这意味着派生类应该与其基类具有相同的接口和行为，不破坏继承关系的稳定性。
④接口隔离原则（Interface Segregation Principle，ISP）：
不应该强迫客户端依赖于它们不使用的接口。这意味着接口应该细化，避免让客户端依赖不需要的方法。
⑤依赖倒置原则（Dependency Inversion Principle，DIP）：
高级模块不应该依赖于低级模块，而两者都应该依赖于抽象。抽象不应该依赖于具体实现，而具体实现应该依赖于抽象。这有助于实现松耦合，提高系统的灵活性和可维护性。


①CGLIB代理是一种基于字节码生成的动态代理技术，允许在运行时创建代理对象，无需依赖接口，可以代理没有实现接口的普通类。

②CGLIB它通过生成目标类的子类，并在子类中拦截对父类方法的调用并添加增强逻辑，从而实现方法的增强，这种方式称为“子类代理”或“继承式代理”。

场景：例如在Spring框架中，当目标类没有实现接口时，Spring会使用CGLIB来创建代理对象，以实现AOP（面向切面编程）和其他功能。


选择题总结：
Spring MVC拦截器包含三个方法：preHandle()、postHandle()、afterCompletion()。
@Autowired是Spring提供的注解，@Resource是JDK提供的注解。它们的区别是，@Autowired只能按类型注入，@Resource默认按名称注入，也支持按类型注入。
用于从URL中提取参数的注解是@PathVariable


@Transactional可以作用在类上，代表这个类的所有公共非静态方法都将启用事务。
可以通过@Transactional的rollbackFor属性，指定发生哪些异常时回滚。
可以通过@Transactional的propagation属性，指定事务的传播行为。
可以通过@Transactional的isolation属性，指定事务的隔离级别。
NESTED表示，若当前存在事务，则采用嵌套事务执行此方法，否则就创建新事务来执行此方法。
REQUIRED：若当前存在事务，就沿用当前事务，否则就新建一个事务来运行此方法。
REQUIRED_NEW：无论当前是否存在事务，都要新建一个事务来运行此方法。
SUPPORTS：若当前存在事务，就沿用当前事务，否则就采用无事务的方式运行此方法。



@Bean注解作用在方法上，表示该方法的返回值将被装配到容器中。
@Bean注解包含name属性，可以通过该属性指定装配的Bean的名称。
@Bean注解通常出现在带有@Configuration注解的类中，但这不是必要的条件，它也可以出现在带有@Component注解的类中，甚至是普通的类中。
@Bean注解可以装配任意的Bean，尤其适合装配那些初始化过程十分复杂的Bean。
Spring容器中Bean包含五种作用域：singleton、prototype、request、session、globalSession。
Spring容器也叫IoC容器，本质上就是一个工厂。
Spring容器不但可以管理Bean，还能管理Bean的生命周期、作用域。

@Autowired：注入声明的SpringBean对象,根据一定的规则首先按照注入的类型去查找，如果没有找到安装注入的名称去匹配你要注入的属性名称，如果都没有找到启动项目时抛出异常，@Autowired(required = false) 表示没有找到注入对象时，不抛异常，注入null。 
@Primary： 如果有多个相同类型的SpringBean,我们可以使用@Primary注解,优先注入带该注解标识的类,@Primary可以在多个类上标注，那就会抛异常。
@Quelifier： 使用SpringBean的名称(SpringBean的名称都是唯一的)进行注入。
当发现有多种类型的Bean时，@Primary注解会通知IoC容器优先使用它所标注的Bean进行注入；
@Quelifier注解可以与@AutoWired注解组合使用，达到通过类型和名称一起筛选Bean的效果。

Spring AOP支持的通知类型包括前置通知、后置通知、环绕通知、返回通知、异常通知。


开发Spring MVC拦截器，需实现WebMvcConfigurer接口。
preHandle方法在Controller之前执行，若返回false，则终止执行后续的请求。
postHandle方法在Controller之后、模板之前执行。
拦截器需实现HandlerInterceptor接口，而WebMvcConfigurer接口是MVC配置类要实现的接口。
